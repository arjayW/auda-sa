<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>audacity: AudioIO Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="audacity.ico"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">audacity
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('class_audio_i_o.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="class_audio_i_o-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">AudioIO Class Reference<span class="mlabels"><span class="mlabel">final</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="class_audio_i_o.html" title="AudioIO uses the PortAudio library to play and record sound.">AudioIO</a> uses the PortAudio library to play and record sound.  
 <a href="class_audio_i_o.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for AudioIO:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_audio_i_o.png" usemap="#AudioIO_map" alt=""/>
  <map id="AudioIO_map" name="AudioIO_map">
<area href="class_audio_io_callback.html" title="AudioIoCallback is a class that implements the callback required by PortAudio. The callback needs to ..." alt="AudioIoCallback" shape="rect" coords="0,0,104,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a78477917ca8c9800ce6f5074a7044399"><td class="memItemLeft" align="right" valign="top"><a id="a78477917ca8c9800ce6f5074a7044399"></a>
<a class="el" href="class_audio_i_o_listener.html">AudioIOListener</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>GetListener</b> ()</td></tr>
<tr class="separator:a78477917ca8c9800ce6f5074a7044399"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d9df4aba253fa43612ac02bafa994fd"><td class="memItemLeft" align="right" valign="top"><a id="a8d9df4aba253fa43612ac02bafa994fd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetListener</b> (<a class="el" href="class_audio_i_o_listener.html">AudioIOListener</a> *listener)</td></tr>
<tr class="separator:a8d9df4aba253fa43612ac02bafa994fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a447c4b556a0f66a61ead1c97ed4ae7e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_audio_i_o.html#a447c4b556a0f66a61ead1c97ed4ae7e7">StartMonitoring</a> (double sampleRate)</td></tr>
<tr class="memdesc:a447c4b556a0f66a61ead1c97ed4ae7e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start up Portaudio for capture and recording as needed for input monitoring and software playthrough only.  <a href="#a447c4b556a0f66a61ead1c97ed4ae7e7">More...</a><br /></td></tr>
<tr class="separator:a447c4b556a0f66a61ead1c97ed4ae7e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b17ce46ff4cc72fed5d125008903422"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_audio_i_o.html#a9b17ce46ff4cc72fed5d125008903422">StartStream</a> (const <a class="el" href="struct_transport_tracks.html">TransportTracks</a> &amp;tracks, double t0, double t1, const <a class="el" href="struct_audio_i_o_start_stream_options.html">AudioIOStartStreamOptions</a> &amp;options)</td></tr>
<tr class="memdesc:a9b17ce46ff4cc72fed5d125008903422"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start recording or playing back audio.  <a href="#a9b17ce46ff4cc72fed5d125008903422">More...</a><br /></td></tr>
<tr class="separator:a9b17ce46ff4cc72fed5d125008903422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a018ef510a8616f1feeb0f542f82b1d44"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_audio_i_o.html#a018ef510a8616f1feeb0f542f82b1d44">StopStream</a> ()</td></tr>
<tr class="memdesc:a018ef510a8616f1feeb0f542f82b1d44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop recording, playback or input monitoring.  <a href="#a018ef510a8616f1feeb0f542f82b1d44">More...</a><br /></td></tr>
<tr class="separator:a018ef510a8616f1feeb0f542f82b1d44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40488ff8506e6238963049844728a6c6"><td class="memItemLeft" align="right" valign="top"><a id="a40488ff8506e6238963049844728a6c6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_audio_i_o.html#a40488ff8506e6238963049844728a6c6">SeekStream</a> (double seconds)</td></tr>
<tr class="memdesc:a40488ff8506e6238963049844728a6c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move the playback / recording position of the current stream by the specified amount from where it is now. <br /></td></tr>
<tr class="separator:a40488ff8506e6238963049844728a6c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7c59454fc751815981db7fd95bf3d91"><td class="memItemLeft" align="right" valign="top"><a id="ab7c59454fc751815981db7fd95bf3d91"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsScrubbing</b> () const</td></tr>
<tr class="separator:ab7c59454fc751815981db7fd95bf3d91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a200139a9d6501ef71183572cfb65b81f"><td class="memItemLeft" align="right" valign="top"><a id="a200139a9d6501ef71183572cfb65b81f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_audio_i_o.html#a200139a9d6501ef71183572cfb65b81f">UpdateScrub</a> (double endTimeOrSpeed, const <a class="el" href="struct_scrubbing_options.html">ScrubbingOptions</a> &amp;options)</td></tr>
<tr class="memdesc:a200139a9d6501ef71183572cfb65b81f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notify scrubbing engine of desired position or speed. If options.adjustStart is true, then when mouse movement exceeds maximum scrub speed, adjust the beginning of the scrub interval rather than the end, so that the scrub skips or "stutters" to stay near the cursor. <br /></td></tr>
<tr class="separator:a200139a9d6501ef71183572cfb65b81f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4f222d36af633e7a5fe5f0edb8e293e"><td class="memItemLeft" align="right" valign="top"><a id="ad4f222d36af633e7a5fe5f0edb8e293e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>StopScrub</b> ()</td></tr>
<tr class="separator:ad4f222d36af633e7a5fe5f0edb8e293e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb4be4414fbb4aaedd6e4da9c4a5dd20"><td class="memItemLeft" align="right" valign="top"><a id="acb4be4414fbb4aaedd6e4da9c4a5dd20"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_audio_i_o.html#acb4be4414fbb4aaedd6e4da9c4a5dd20">GetLastScrubTime</a> () const</td></tr>
<tr class="memdesc:acb4be4414fbb4aaedd6e4da9c4a5dd20"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the ending time of the last scrub interval. <br /></td></tr>
<tr class="separator:acb4be4414fbb4aaedd6e4da9c4a5dd20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a141109b199851f00d55507de40737eb1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_audio_i_o.html#a141109b199851f00d55507de40737eb1">IsBusy</a> () const</td></tr>
<tr class="memdesc:a141109b199851f00d55507de40737eb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if audio i/o is busy starting, stopping, playing, or recording.  <a href="#a141109b199851f00d55507de40737eb1">More...</a><br /></td></tr>
<tr class="separator:a141109b199851f00d55507de40737eb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae69fc36ead257005079701907f7be714"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_audio_i_o.html#ae69fc36ead257005079701907f7be714">IsStreamActive</a> () const</td></tr>
<tr class="memdesc:ae69fc36ead257005079701907f7be714"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the audio i/o is running at all, but not during cleanup.  <a href="#ae69fc36ead257005079701907f7be714">More...</a><br /></td></tr>
<tr class="separator:ae69fc36ead257005079701907f7be714"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a366add0593c4c0db12a0c67afbf0beb7"><td class="memItemLeft" align="right" valign="top"><a id="a366add0593c4c0db12a0c67afbf0beb7"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsStreamActive</b> (int token) const</td></tr>
<tr class="separator:a366add0593c4c0db12a0c67afbf0beb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7151c7c1d4de0c494a8491d02e5e3f2"><td class="memItemLeft" align="right" valign="top"><a id="ae7151c7c1d4de0c494a8491d02e5e3f2"></a>
wxString&#160;</td><td class="memItemRight" valign="bottom"><b>LastPaErrorString</b> ()</td></tr>
<tr class="separator:ae7151c7c1d4de0c494a8491d02e5e3f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64544475366e9fd3b161e053a449d463"><td class="memItemLeft" align="right" valign="top"><a id="a64544475366e9fd3b161e053a449d463"></a>
wxLongLong&#160;</td><td class="memItemRight" valign="bottom"><b>GetLastPlaybackTime</b> () const</td></tr>
<tr class="separator:a64544475366e9fd3b161e053a449d463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5512bfc9753023ad090cf956321420b9"><td class="memItemLeft" align="right" valign="top"><a id="a5512bfc9753023ad090cf956321420b9"></a>
<a class="el" href="class_audacity_project.html">AudacityProject</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>GetOwningProject</b> () const</td></tr>
<tr class="separator:a5512bfc9753023ad090cf956321420b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a654d0ad7189af7767a658cbb98505fd5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_audio_i_o.html#a654d0ad7189af7767a658cbb98505fd5">IsAudioTokenActive</a> (int token) const</td></tr>
<tr class="memdesc:a654d0ad7189af7767a658cbb98505fd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the stream is active, or even if audio I/O is busy cleaning up its data or writing to disk.  <a href="#a654d0ad7189af7767a658cbb98505fd5">More...</a><br /></td></tr>
<tr class="separator:a654d0ad7189af7767a658cbb98505fd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dc54fc98c90cbcbf0ab91a0d80d562c"><td class="memItemLeft" align="right" valign="top"><a id="a4dc54fc98c90cbcbf0ab91a0d80d562c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_audio_i_o.html#a4dc54fc98c90cbcbf0ab91a0d80d562c">IsMonitoring</a> () const</td></tr>
<tr class="memdesc:a4dc54fc98c90cbcbf0ab91a0d80d562c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if we're monitoring input (but not recording or playing actual audio) <br /></td></tr>
<tr class="separator:a4dc54fc98c90cbcbf0ab91a0d80d562c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49f8574c7ce8410e3ab254fe95c44388"><td class="memItemLeft" align="right" valign="top"><a id="a49f8574c7ce8410e3ab254fe95c44388"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_audio_i_o.html#a49f8574c7ce8410e3ab254fe95c44388">SetPaused</a> (bool state)</td></tr>
<tr class="memdesc:a49f8574c7ce8410e3ab254fe95c44388"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pause and un-pause playback and recording. <br /></td></tr>
<tr class="separator:a49f8574c7ce8410e3ab254fe95c44388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab90a44dee504b8748bf321416a25067b"><td class="memItemLeft" align="right" valign="top"><a id="ab90a44dee504b8748bf321416a25067b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetMixer</b> (int inputSource)</td></tr>
<tr class="separator:ab90a44dee504b8748bf321416a25067b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e08d80f05a4106be20dfaa96723c957"><td class="memItemLeft" align="right" valign="top"><a id="a6e08d80f05a4106be20dfaa96723c957"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetMixer</b> (int inputSource, float inputVolume, float playbackVolume)</td></tr>
<tr class="separator:a6e08d80f05a4106be20dfaa96723c957"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2341f380ecf5d7630ed1879a1b66e28c"><td class="memItemLeft" align="right" valign="top"><a id="a2341f380ecf5d7630ed1879a1b66e28c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>GetMixer</b> (int *inputSource, float *inputVolume, float *playbackVolume)</td></tr>
<tr class="separator:a2341f380ecf5d7630ed1879a1b66e28c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a104cc037e35b66adb8864a35e8376f8e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_audio_i_o.html#a104cc037e35b66adb8864a35e8376f8e">InputMixerWorks</a> ()</td></tr>
<tr class="memdesc:a104cc037e35b66adb8864a35e8376f8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find out if the input hardware level control is available.  <a href="#a104cc037e35b66adb8864a35e8376f8e">More...</a><br /></td></tr>
<tr class="separator:a104cc037e35b66adb8864a35e8376f8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc4c1f9f7609603270df993ee8af1af2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_audio_i_o.html#abc4c1f9f7609603270df993ee8af1af2">OutputMixerEmulated</a> ()</td></tr>
<tr class="memdesc:abc4c1f9f7609603270df993ee8af1af2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find out if the output level control is being emulated via software attenuation.  <a href="#abc4c1f9f7609603270df993ee8af1af2">More...</a><br /></td></tr>
<tr class="separator:abc4c1f9f7609603270df993ee8af1af2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a871ad77e029d77ff4ae461b2be5325cd"><td class="memItemLeft" align="right" valign="top">wxArrayString&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_audio_i_o.html#a871ad77e029d77ff4ae461b2be5325cd">GetInputSourceNames</a> ()</td></tr>
<tr class="memdesc:a871ad77e029d77ff4ae461b2be5325cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the list of inputs to the current mixer device.  <a href="#a871ad77e029d77ff4ae461b2be5325cd">More...</a><br /></td></tr>
<tr class="separator:a871ad77e029d77ff4ae461b2be5325cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef42a8e615a55e2b914a989e8b63af0b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_audio_i_o.html#aef42a8e615a55e2b914a989e8b63af0b">HandleDeviceChange</a> ()</td></tr>
<tr class="memdesc:aef42a8e615a55e2b914a989e8b63af0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">update state after changing what audio devices are selected  <a href="#aef42a8e615a55e2b914a989e8b63af0b">More...</a><br /></td></tr>
<tr class="separator:aef42a8e615a55e2b914a989e8b63af0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaf7977e341e8012b03dca8c733f24e1"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_audio_i_o.html#adaf7977e341e8012b03dca8c733f24e1">GetStreamTime</a> ()</td></tr>
<tr class="memdesc:adaf7977e341e8012b03dca8c733f24e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">During playback, the track time most recently played.  <a href="#adaf7977e341e8012b03dca8c733f24e1">More...</a><br /></td></tr>
<tr class="separator:adaf7977e341e8012b03dca8c733f24e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5735d00a230e2a59a9702dfbf1a8b85d"><td class="memItemLeft" align="right" valign="top"><a id="a5735d00a230e2a59a9702dfbf1a8b85d"></a>
sampleFormat&#160;</td><td class="memItemRight" valign="bottom"><b>GetCaptureFormat</b> ()</td></tr>
<tr class="separator:a5735d00a230e2a59a9702dfbf1a8b85d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab774bca1072b98840c237c830a1d5ccd"><td class="memItemLeft" align="right" valign="top"><a id="ab774bca1072b98840c237c830a1d5ccd"></a>
unsigned&#160;</td><td class="memItemRight" valign="bottom"><b>GetNumPlaybackChannels</b> () const</td></tr>
<tr class="separator:ab774bca1072b98840c237c830a1d5ccd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37f7a8466278038cf9c69fa8f1b8695c"><td class="memItemLeft" align="right" valign="top"><a id="a37f7a8466278038cf9c69fa8f1b8695c"></a>
unsigned&#160;</td><td class="memItemRight" valign="bottom"><b>GetNumCaptureChannels</b> () const</td></tr>
<tr class="separator:a37f7a8466278038cf9c69fa8f1b8695c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f58047155abf551e12697d332d7db68"><td class="memItemLeft" align="right" valign="top"><a id="a0f58047155abf551e12697d332d7db68"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsCapturing</b> () const</td></tr>
<tr class="separator:a0f58047155abf551e12697d332d7db68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a134b6a56921f9c6bd197d80de4ddce48"><td class="memItemLeft" align="right" valign="top">wxString&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_audio_i_o.html#a134b6a56921f9c6bd197d80de4ddce48">GetDeviceInfo</a> ()</td></tr>
<tr class="memdesc:a134b6a56921f9c6bd197d80de4ddce48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get diagnostic information on all the available audio I/O devices.  <a href="#a134b6a56921f9c6bd197d80de4ddce48">More...</a><br /></td></tr>
<tr class="separator:a134b6a56921f9c6bd197d80de4ddce48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8241ebe3d067da25f0b987d599c18e0a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_audio_i_o.html#a8241ebe3d067da25f0b987d599c18e0a">IsAvailable</a> (<a class="el" href="class_audacity_project.html">AudacityProject</a> *projecT) const</td></tr>
<tr class="memdesc:a8241ebe3d067da25f0b987d599c18e0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to automatically set an acceptable volume.  <a href="#a8241ebe3d067da25f0b987d599c18e0a">More...</a><br /></td></tr>
<tr class="separator:a8241ebe3d067da25f0b987d599c18e0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2162306b9ee1835891500d149b075518"><td class="memItemLeft" align="right" valign="top"><a id="a2162306b9ee1835891500d149b075518"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetCaptureMeter</b> (<a class="el" href="class_audacity_project.html">AudacityProject</a> *project, <a class="el" href="class_meter_panel.html">MeterPanel</a> *meter)</td></tr>
<tr class="separator:a2162306b9ee1835891500d149b075518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1421e703716ad91cb8a70b4d8504dc3f"><td class="memItemLeft" align="right" valign="top"><a id="a1421e703716ad91cb8a70b4d8504dc3f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetPlaybackMeter</b> (<a class="el" href="class_audacity_project.html">AudacityProject</a> *project, <a class="el" href="class_meter_panel.html">MeterPanel</a> *meter)</td></tr>
<tr class="separator:a1421e703716ad91cb8a70b4d8504dc3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6489917b96acd5c4868b42724f1245a3"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_audio_i_o.html#a6489917b96acd5c4868b42724f1245a3">GetBestRate</a> (bool capturing, bool playing, double sampleRate)</td></tr>
<tr class="memdesc:a6489917b96acd5c4868b42724f1245a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a valid sample rate that is supported by the current I/O device(s).  <a href="#a6489917b96acd5c4868b42724f1245a3">More...</a><br /></td></tr>
<tr class="separator:a6489917b96acd5c4868b42724f1245a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_audio_io_callback"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_audio_io_callback')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_audio_io_callback.html">AudioIoCallback</a></td></tr>
<tr class="memitem:a487a6bf8cdd7ed85f772f46e54f56def inherit pub_methods_class_audio_io_callback"><td class="memItemLeft" align="right" valign="top"><a id="a487a6bf8cdd7ed85f772f46e54f56def"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>AudioCallback</b> (const void *inputBuffer, void *outputBuffer, unsigned long framesPerBuffer, const PaStreamCallbackTimeInfo *timeInfo, const PaStreamCallbackFlags statusFlags, void *userData)</td></tr>
<tr class="separator:a487a6bf8cdd7ed85f772f46e54f56def inherit pub_methods_class_audio_io_callback"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54a8dd0418ba701e499d5cab864c29a7 inherit pub_methods_class_audio_io_callback"><td class="memItemLeft" align="right" valign="top"><a id="a54a8dd0418ba701e499d5cab864c29a7"></a>
PaStreamCallbackResult&#160;</td><td class="memItemRight" valign="bottom"><b>CallbackDoSeek</b> ()</td></tr>
<tr class="separator:a54a8dd0418ba701e499d5cab864c29a7 inherit pub_methods_class_audio_io_callback"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1124aa338516bc78dea6410566442d4a inherit pub_methods_class_audio_io_callback"><td class="memItemLeft" align="right" valign="top"><a id="a1124aa338516bc78dea6410566442d4a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>CallbackCheckCompletion</b> (int &amp;callbackReturn, unsigned long len)</td></tr>
<tr class="separator:a1124aa338516bc78dea6410566442d4a inherit pub_methods_class_audio_io_callback"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3504ebdbde3256198dca7cc36abe4f53 inherit pub_methods_class_audio_io_callback"><td class="memItemLeft" align="right" valign="top"><a id="a3504ebdbde3256198dca7cc36abe4f53"></a>
unsigned&#160;</td><td class="memItemRight" valign="bottom"><b>CountSoloingTracks</b> ()</td></tr>
<tr class="separator:a3504ebdbde3256198dca7cc36abe4f53 inherit pub_methods_class_audio_io_callback"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f0e09f9c5fcc04098f807a134f7e54e inherit pub_methods_class_audio_io_callback"><td class="memItemLeft" align="right" valign="top"><a id="a0f0e09f9c5fcc04098f807a134f7e54e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>TrackShouldBeSilent</b> (const <a class="el" href="class_wave_track.html">WaveTrack</a> &amp;wt)</td></tr>
<tr class="separator:a0f0e09f9c5fcc04098f807a134f7e54e inherit pub_methods_class_audio_io_callback"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f5300c4b43e0d659ab7481ce605cdf9 inherit pub_methods_class_audio_io_callback"><td class="memItemLeft" align="right" valign="top"><a id="a3f5300c4b43e0d659ab7481ce605cdf9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>TrackHasBeenFadedOut</b> (const <a class="el" href="class_wave_track.html">WaveTrack</a> &amp;wt)</td></tr>
<tr class="separator:a3f5300c4b43e0d659ab7481ce605cdf9 inherit pub_methods_class_audio_io_callback"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d5d7996e682009c489623849fbc5506 inherit pub_methods_class_audio_io_callback"><td class="memItemLeft" align="right" valign="top"><a id="a1d5d7996e682009c489623849fbc5506"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>AllTracksAlreadySilent</b> ()</td></tr>
<tr class="separator:a1d5d7996e682009c489623849fbc5506 inherit pub_methods_class_audio_io_callback"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1089814e7d5261c08afe9c7c0200df7d inherit pub_methods_class_audio_io_callback"><td class="memItemLeft" align="right" valign="top"><a id="a1089814e7d5261c08afe9c7c0200df7d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ComputeMidiTimings</b> (const PaStreamCallbackTimeInfo *timeInfo, unsigned long framesPerBuffer)</td></tr>
<tr class="separator:a1089814e7d5261c08afe9c7c0200df7d inherit pub_methods_class_audio_io_callback"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa904cf3782d30b33f0d274bfecb1bf55 inherit pub_methods_class_audio_io_callback"><td class="memItemLeft" align="right" valign="top"><a id="aa904cf3782d30b33f0d274bfecb1bf55"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>CheckSoundActivatedRecordingLevel</b> (const void *inputBuffer)</td></tr>
<tr class="separator:aa904cf3782d30b33f0d274bfecb1bf55 inherit pub_methods_class_audio_io_callback"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5b75c4d22017fbaf8d198431571ce9a inherit pub_methods_class_audio_io_callback"><td class="memItemLeft" align="right" valign="top"><a id="ac5b75c4d22017fbaf8d198431571ce9a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>AddToOutputChannel</b> (unsigned int chan, float *outputMeterFloats, float *outputFloats, float *tempFloats, float *tempBuf, bool drop, unsigned long len, <a class="el" href="class_wave_track.html">WaveTrack</a> *vt)</td></tr>
<tr class="separator:ac5b75c4d22017fbaf8d198431571ce9a inherit pub_methods_class_audio_io_callback"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f74ba91c4b789dfa990dd7d890af3ae inherit pub_methods_class_audio_io_callback"><td class="memItemLeft" align="right" valign="top"><a id="a8f74ba91c4b789dfa990dd7d890af3ae"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>FillOutputBuffers</b> (void *outputBuffer, unsigned long framesPerBuffer, float *tempFloats, float *outputMeterFloats)</td></tr>
<tr class="separator:a8f74ba91c4b789dfa990dd7d890af3ae inherit pub_methods_class_audio_io_callback"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cd8d4d309c5234afdf4519717ac3630 inherit pub_methods_class_audio_io_callback"><td class="memItemLeft" align="right" valign="top"><a id="a2cd8d4d309c5234afdf4519717ac3630"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>FillInputBuffers</b> (const void *inputBuffer, unsigned long framesPerBuffer, const PaStreamCallbackFlags statusFlags, float *tempFloats)</td></tr>
<tr class="separator:a2cd8d4d309c5234afdf4519717ac3630 inherit pub_methods_class_audio_io_callback"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c3bd0c02b0029f9841c6d30d3cd5455 inherit pub_methods_class_audio_io_callback"><td class="memItemLeft" align="right" valign="top"><a id="a2c3bd0c02b0029f9841c6d30d3cd5455"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>UpdateTimePosition</b> (unsigned long framesPerBuffer)</td></tr>
<tr class="separator:a2c3bd0c02b0029f9841c6d30d3cd5455 inherit pub_methods_class_audio_io_callback"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc7256df217df27bc57887d2b534b462 inherit pub_methods_class_audio_io_callback"><td class="memItemLeft" align="right" valign="top"><a id="adc7256df217df27bc57887d2b534b462"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>DoPlaythrough</b> (const void *inputBuffer, void *outputBuffer, unsigned long framesPerBuffer, float *outputMeterFloats)</td></tr>
<tr class="separator:adc7256df217df27bc57887d2b534b462 inherit pub_methods_class_audio_io_callback"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab095c81e1b41840a45d521086910065 inherit pub_methods_class_audio_io_callback"><td class="memItemLeft" align="right" valign="top"><a id="aab095c81e1b41840a45d521086910065"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SendVuInputMeterData</b> (float *tempFloats, const void *inputBuffer, unsigned long framesPerBuffer)</td></tr>
<tr class="separator:aab095c81e1b41840a45d521086910065 inherit pub_methods_class_audio_io_callback"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7c6c6810eaa04f6aae7e635de2ec016 inherit pub_methods_class_audio_io_callback"><td class="memItemLeft" align="right" valign="top"><a id="aa7c6c6810eaa04f6aae7e635de2ec016"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SendVuOutputMeterData</b> (float *outputMeterFloats, unsigned long framesPerBuffer)</td></tr>
<tr class="separator:aa7c6c6810eaa04f6aae7e635de2ec016 inherit pub_methods_class_audio_io_callback"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e36d88c14afab1f889cd379c5ac1441 inherit pub_methods_class_audio_io_callback"><td class="memItemLeft" align="right" valign="top"><a id="a4e36d88c14afab1f889cd379c5ac1441"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_audio_io_callback.html#a4e36d88c14afab1f889cd379c5ac1441">IsPaused</a> () const</td></tr>
<tr class="memdesc:a4e36d88c14afab1f889cd379c5ac1441 inherit pub_methods_class_audio_io_callback"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find out if playback / recording is currently paused. <br /></td></tr>
<tr class="separator:a4e36d88c14afab1f889cd379c5ac1441 inherit pub_methods_class_audio_io_callback"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca92c534a3a20d8b0f2520babc1b824c inherit pub_methods_class_audio_io_callback"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_audio_io_callback.html#aca92c534a3a20d8b0f2520babc1b824c">GetCommonlyReadyPlayback</a> ()</td></tr>
<tr class="memdesc:aca92c534a3a20d8b0f2520babc1b824c inherit pub_methods_class_audio_io_callback"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of audio samples ready in all of the playback buffers.  <a href="class_audio_io_callback.html#aca92c534a3a20d8b0f2520babc1b824c">More...</a><br /></td></tr>
<tr class="separator:aca92c534a3a20d8b0f2520babc1b824c inherit pub_methods_class_audio_io_callback"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01dd8c1c0dd6bf60bccbfe92a1204881 inherit pub_methods_class_audio_io_callback"><td class="memItemLeft" align="right" valign="top"><a id="a01dd8c1c0dd6bf60bccbfe92a1204881"></a>
const std::vector&lt; std::pair&lt; double, double &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>LostCaptureIntervals</b> ()</td></tr>
<tr class="separator:a01dd8c1c0dd6bf60bccbfe92a1204881 inherit pub_methods_class_audio_io_callback"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a9abda9144bad168794547234df2a1c4e"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; long &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_audio_i_o.html#a9abda9144bad168794547234df2a1c4e">GetSupportedPlaybackRates</a> (int DevIndex=-1, double rate=0.0)</td></tr>
<tr class="memdesc:a9abda9144bad168794547234df2a1c4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a list of sample rates the output (playback) device supports.  <a href="#a9abda9144bad168794547234df2a1c4e">More...</a><br /></td></tr>
<tr class="separator:a9abda9144bad168794547234df2a1c4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66836a8e3a6687b0c6c0220685e51144"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; long &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_audio_i_o.html#a66836a8e3a6687b0c6c0220685e51144">GetSupportedCaptureRates</a> (int devIndex=-1, double rate=0.0)</td></tr>
<tr class="memdesc:a66836a8e3a6687b0c6c0220685e51144"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a list of sample rates the input (recording) device supports.  <a href="#a66836a8e3a6687b0c6c0220685e51144">More...</a><br /></td></tr>
<tr class="separator:a66836a8e3a6687b0c6c0220685e51144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59a87873003096edc7c4359ed5de5ecb"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; long &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_audio_i_o.html#a59a87873003096edc7c4359ed5de5ecb">GetSupportedSampleRates</a> (int playDevice=-1, int recDevice=-1, double rate=0.0)</td></tr>
<tr class="memdesc:a59a87873003096edc7c4359ed5de5ecb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a list of sample rates the current input/output device combination supports.  <a href="#a59a87873003096edc7c4359ed5de5ecb">More...</a><br /></td></tr>
<tr class="separator:a59a87873003096edc7c4359ed5de5ecb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71facd3c7274394b70eaff652e1bc97e"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_audio_i_o.html#a71facd3c7274394b70eaff652e1bc97e">GetOptimalSupportedSampleRate</a> ()</td></tr>
<tr class="memdesc:a71facd3c7274394b70eaff652e1bc97e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a supported sample rate which can be used a an optimal default.  <a href="#a71facd3c7274394b70eaff652e1bc97e">More...</a><br /></td></tr>
<tr class="separator:a71facd3c7274394b70eaff652e1bc97e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfaf9b48ca72d2d34ebfb8873e0ae7dd"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_audio_i_o.html#acfaf9b48ca72d2d34ebfb8873e0ae7dd">ValidateDeviceNames</a> (const wxString &amp;play, const wxString &amp;rec)</td></tr>
<tr class="memdesc:acfaf9b48ca72d2d34ebfb8873e0ae7dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensure selected device names are valid.  <a href="#acfaf9b48ca72d2d34ebfb8873e0ae7dd">More...</a><br /></td></tr>
<tr class="separator:acfaf9b48ca72d2d34ebfb8873e0ae7dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a42f4cf4090548388aa1c762bb59778ba"><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_audio_i_o.html#a42f4cf4090548388aa1c762bb59778ba">StandardRates</a> []</td></tr>
<tr class="memdesc:a42f4cf4090548388aa1c762bb59778ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of common audio sample rates.  <a href="#a42f4cf4090548388aa1c762bb59778ba">More...</a><br /></td></tr>
<tr class="separator:a42f4cf4090548388aa1c762bb59778ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d794f0244d6be2f833a6627cbfcdae8"><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_audio_i_o.html#a4d794f0244d6be2f833a6627cbfcdae8">NumStandardRates</a></td></tr>
<tr class="memdesc:a4d794f0244d6be2f833a6627cbfcdae8"><td class="mdescLeft">&#160;</td><td class="mdescRight">How many standard sample rates there are.  <a href="#a4d794f0244d6be2f833a6627cbfcdae8">More...</a><br /></td></tr>
<tr class="separator:a4d794f0244d6be2f833a6627cbfcdae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_attribs_class_audio_io_callback"><td colspan="2" onclick="javascript:toggleInherit('pub_static_attribs_class_audio_io_callback')"><img src="closed.png" alt="-"/>&#160;Static Public Attributes inherited from <a class="el" href="class_audio_io_callback.html">AudioIoCallback</a></td></tr>
<tr class="memitem:a062f94f65f9f85b67b341f5f6d12dd42 inherit pub_static_attribs_class_audio_io_callback"><td class="memItemLeft" align="right" valign="top"><a id="a062f94f65f9f85b67b341f5f6d12dd42"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>mNextStreamToken</b> = 0</td></tr>
<tr class="separator:a062f94f65f9f85b67b341f5f6d12dd42 inherit pub_static_attribs_class_audio_io_callback"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a894b7c943c91bb34f845aeb117786dff"><td class="memItemLeft" align="right" valign="top"><a id="a894b7c943c91bb34f845aeb117786dff"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>AudioThread</b></td></tr>
<tr class="separator:a894b7c943c91bb34f845aeb117786dff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c082d9ef3612f42a4a78edffdf2a0db"><td class="memItemLeft" align="right" valign="top"><a id="a5c082d9ef3612f42a4a78edffdf2a0db"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>InitAudioIO</b> ()</td></tr>
<tr class="separator:a5c082d9ef3612f42a4a78edffdf2a0db"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_attribs_class_audio_io_callback"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_class_audio_io_callback')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="class_audio_io_callback.html">AudioIoCallback</a></td></tr>
<tr class="memitem:a7e932c735036ef23d716ccf6db3cc26a inherit pub_attribs_class_audio_io_callback"><td class="memItemLeft" align="right" valign="top"><a id="a7e932c735036ef23d716ccf6db3cc26a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>mbHasSoloTracks</b></td></tr>
<tr class="separator:a7e932c735036ef23d716ccf6db3cc26a inherit pub_attribs_class_audio_io_callback"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47c4de3e87770e5abb5bffb442a1e5fb inherit pub_attribs_class_audio_io_callback"><td class="memItemLeft" align="right" valign="top"><a id="a47c4de3e87770e5abb5bffb442a1e5fb"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>mCallbackReturn</b></td></tr>
<tr class="separator:a47c4de3e87770e5abb5bffb442a1e5fb inherit pub_attribs_class_audio_io_callback"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0815984f97f86b6abbfded625f0002c inherit pub_attribs_class_audio_io_callback"><td class="memItemLeft" align="right" valign="top"><a id="ae0815984f97f86b6abbfded625f0002c"></a>
std::unique_ptr&lt; <a class="el" href="class_audio_thread.html">AudioThread</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>mThread</b></td></tr>
<tr class="separator:ae0815984f97f86b6abbfded625f0002c inherit pub_attribs_class_audio_io_callback"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad637b5292685013f7f65c3c35397ac97 inherit pub_attribs_class_audio_io_callback"><td class="memItemLeft" align="right" valign="top"><a id="ad637b5292685013f7f65c3c35397ac97"></a>
<a class="el" href="class_array_of.html">ArrayOf</a>&lt; std::unique_ptr&lt; <a class="el" href="class_resample.html">Resample</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>mResample</b></td></tr>
<tr class="separator:ad637b5292685013f7f65c3c35397ac97 inherit pub_attribs_class_audio_io_callback"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a8bcf3e3f9e9c933ac1a152c9a1f414 inherit pub_attribs_class_audio_io_callback"><td class="memItemLeft" align="right" valign="top"><a id="a9a8bcf3e3f9e9c933ac1a152c9a1f414"></a>
<a class="el" href="class_array_of.html">ArrayOf</a>&lt; std::unique_ptr&lt; <a class="el" href="class_ring_buffer.html">RingBuffer</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>mCaptureBuffers</b></td></tr>
<tr class="separator:a9a8bcf3e3f9e9c933ac1a152c9a1f414 inherit pub_attribs_class_audio_io_callback"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4d804c798e0de93089f801993114638 inherit pub_attribs_class_audio_io_callback"><td class="memItemLeft" align="right" valign="top"><a id="ab4d804c798e0de93089f801993114638"></a>
WaveTrackArray&#160;</td><td class="memItemRight" valign="bottom"><b>mCaptureTracks</b></td></tr>
<tr class="separator:ab4d804c798e0de93089f801993114638 inherit pub_attribs_class_audio_io_callback"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af929c6fbcb0410ef4bb70e8af701cee7 inherit pub_attribs_class_audio_io_callback"><td class="memItemLeft" align="right" valign="top"><a id="af929c6fbcb0410ef4bb70e8af701cee7"></a>
<a class="el" href="class_array_of.html">ArrayOf</a>&lt; std::unique_ptr&lt; <a class="el" href="class_ring_buffer.html">RingBuffer</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>mPlaybackBuffers</b></td></tr>
<tr class="separator:af929c6fbcb0410ef4bb70e8af701cee7 inherit pub_attribs_class_audio_io_callback"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f459c9daa3712a2c046fd8b1f0e1a46 inherit pub_attribs_class_audio_io_callback"><td class="memItemLeft" align="right" valign="top"><a id="a7f459c9daa3712a2c046fd8b1f0e1a46"></a>
WaveTrackArray&#160;</td><td class="memItemRight" valign="bottom"><b>mPlaybackTracks</b></td></tr>
<tr class="separator:a7f459c9daa3712a2c046fd8b1f0e1a46 inherit pub_attribs_class_audio_io_callback"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f31ecfe2335aecdfec112af1114acb1 inherit pub_attribs_class_audio_io_callback"><td class="memItemLeft" align="right" valign="top"><a id="a6f31ecfe2335aecdfec112af1114acb1"></a>
<a class="el" href="class_array_of.html">ArrayOf</a>&lt; std::unique_ptr&lt; <a class="el" href="class_mixer.html">Mixer</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>mPlaybackMixers</b></td></tr>
<tr class="separator:a6f31ecfe2335aecdfec112af1114acb1 inherit pub_attribs_class_audio_io_callback"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a8d08ddf6676288d6856ff945295165 inherit pub_attribs_class_audio_io_callback"><td class="memItemLeft" align="right" valign="top"><a id="a4a8d08ddf6676288d6856ff945295165"></a>
volatile int&#160;</td><td class="memItemRight" valign="bottom"><b>mStreamToken</b></td></tr>
<tr class="separator:a4a8d08ddf6676288d6856ff945295165 inherit pub_attribs_class_audio_io_callback"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebdf9786c304b27885daf57ca2aa2c50 inherit pub_attribs_class_audio_io_callback"><td class="memItemLeft" align="right" valign="top"><a id="aebdf9786c304b27885daf57ca2aa2c50"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>mFactor</b></td></tr>
<tr class="separator:aebdf9786c304b27885daf57ca2aa2c50 inherit pub_attribs_class_audio_io_callback"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56ed8d2c37cb84c5c2bc0f9b99b578ee inherit pub_attribs_class_audio_io_callback"><td class="memItemLeft" align="right" valign="top"><a id="a56ed8d2c37cb84c5c2bc0f9b99b578ee"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_audio_io_callback.html#a56ed8d2c37cb84c5c2bc0f9b99b578ee">mRate</a></td></tr>
<tr class="memdesc:a56ed8d2c37cb84c5c2bc0f9b99b578ee inherit pub_attribs_class_audio_io_callback"><td class="mdescLeft">&#160;</td><td class="mdescRight">Audio playback rate in samples per second. <br /></td></tr>
<tr class="separator:a56ed8d2c37cb84c5c2bc0f9b99b578ee inherit pub_attribs_class_audio_io_callback"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abef045e34fccf786521c2291c325ff72 inherit pub_attribs_class_audio_io_callback"><td class="memItemLeft" align="right" valign="top"><a id="abef045e34fccf786521c2291c325ff72"></a>
unsigned long&#160;</td><td class="memItemRight" valign="bottom"><b>mMaxFramesOutput</b></td></tr>
<tr class="separator:abef045e34fccf786521c2291c325ff72 inherit pub_attribs_class_audio_io_callback"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1166ec5d067f5fd74c0a481acfd295c7 inherit pub_attribs_class_audio_io_callback"><td class="memItemLeft" align="right" valign="top"><a id="a1166ec5d067f5fd74c0a481acfd295c7"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>mbMicroFades</b></td></tr>
<tr class="separator:a1166ec5d067f5fd74c0a481acfd295c7 inherit pub_attribs_class_audio_io_callback"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14751032a0c1bdc9ff6e0d6e7c01bbb5 inherit pub_attribs_class_audio_io_callback"><td class="memItemLeft" align="right" valign="top"><a id="a14751032a0c1bdc9ff6e0d6e7c01bbb5"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>mSeek</b></td></tr>
<tr class="separator:a14751032a0c1bdc9ff6e0d6e7c01bbb5 inherit pub_attribs_class_audio_io_callback"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a880b791c49d9a97cfbba9b4546918c82 inherit pub_attribs_class_audio_io_callback"><td class="memItemLeft" align="right" valign="top"><a id="a880b791c49d9a97cfbba9b4546918c82"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>mPlaybackRingBufferSecs</b></td></tr>
<tr class="separator:a880b791c49d9a97cfbba9b4546918c82 inherit pub_attribs_class_audio_io_callback"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6dc68303d490d8dc8077baa6a4f4a84 inherit pub_attribs_class_audio_io_callback"><td class="memItemLeft" align="right" valign="top"><a id="ad6dc68303d490d8dc8077baa6a4f4a84"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>mCaptureRingBufferSecs</b></td></tr>
<tr class="separator:ad6dc68303d490d8dc8077baa6a4f4a84 inherit pub_attribs_class_audio_io_callback"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31b9c88d215468584987bf2624104135 inherit pub_attribs_class_audio_io_callback"><td class="memItemLeft" align="right" valign="top"><a id="a31b9c88d215468584987bf2624104135"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_audio_io_callback.html#a31b9c88d215468584987bf2624104135">mPlaybackSamplesToCopy</a></td></tr>
<tr class="memdesc:a31b9c88d215468584987bf2624104135 inherit pub_attribs_class_audio_io_callback"><td class="mdescLeft">&#160;</td><td class="mdescRight">Preferred batch size for replenishing the playback <a class="el" href="class_ring_buffer.html" title="Holds streamed audio samples.">RingBuffer</a>. <br /></td></tr>
<tr class="separator:a31b9c88d215468584987bf2624104135 inherit pub_attribs_class_audio_io_callback"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1744836d75d43d7e120ce7602412b64 inherit pub_attribs_class_audio_io_callback"><td class="memItemLeft" align="right" valign="top"><a id="ad1744836d75d43d7e120ce7602412b64"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_audio_io_callback.html#ad1744836d75d43d7e120ce7602412b64">mPlaybackQueueMinimum</a></td></tr>
<tr class="memdesc:ad1744836d75d43d7e120ce7602412b64 inherit pub_attribs_class_audio_io_callback"><td class="mdescLeft">&#160;</td><td class="mdescRight">Occupancy of the queue we try to maintain, with bigger batches if needed. <br /></td></tr>
<tr class="separator:ad1744836d75d43d7e120ce7602412b64 inherit pub_attribs_class_audio_io_callback"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af980004c648f07b8bbdc869d7e7a3427 inherit pub_attribs_class_audio_io_callback"><td class="memItemLeft" align="right" valign="top"><a id="af980004c648f07b8bbdc869d7e7a3427"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>mMinCaptureSecsToCopy</b></td></tr>
<tr class="separator:af980004c648f07b8bbdc869d7e7a3427 inherit pub_attribs_class_audio_io_callback"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89f232384f0c412e95624c3ca5961d5d inherit pub_attribs_class_audio_io_callback"><td class="memItemLeft" align="right" valign="top"><a id="a89f232384f0c412e95624c3ca5961d5d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_audio_io_callback.html#a89f232384f0c412e95624c3ca5961d5d">mPaused</a></td></tr>
<tr class="memdesc:a89f232384f0c412e95624c3ca5961d5d inherit pub_attribs_class_audio_io_callback"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if audio playback is paused. <br /></td></tr>
<tr class="separator:a89f232384f0c412e95624c3ca5961d5d inherit pub_attribs_class_audio_io_callback"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86396756e075d37fca115580d2e83607 inherit pub_attribs_class_audio_io_callback"><td class="memItemLeft" align="right" valign="top"><a id="a86396756e075d37fca115580d2e83607"></a>
PaStream *&#160;</td><td class="memItemRight" valign="bottom"><b>mPortStreamV19</b></td></tr>
<tr class="separator:a86396756e075d37fca115580d2e83607 inherit pub_attribs_class_audio_io_callback"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a942f681d19e448f1f0e1fbc24c29765f inherit pub_attribs_class_audio_io_callback"><td class="memItemLeft" align="right" valign="top"><a id="a942f681d19e448f1f0e1fbc24c29765f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>mSoftwarePlaythrough</b></td></tr>
<tr class="separator:a942f681d19e448f1f0e1fbc24c29765f inherit pub_attribs_class_audio_io_callback"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea4f6f67ebc407837e73e67a1a9244c8 inherit pub_attribs_class_audio_io_callback"><td class="memItemLeft" align="right" valign="top"><a id="aea4f6f67ebc407837e73e67a1a9244c8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_audio_io_callback.html#aea4f6f67ebc407837e73e67a1a9244c8">mPauseRec</a></td></tr>
<tr class="memdesc:aea4f6f67ebc407837e73e67a1a9244c8 inherit pub_attribs_class_audio_io_callback"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if Sound Activated Recording is enabled. <br /></td></tr>
<tr class="separator:aea4f6f67ebc407837e73e67a1a9244c8 inherit pub_attribs_class_audio_io_callback"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad86c2ca6fcb93cb79fade331ab9bd161 inherit pub_attribs_class_audio_io_callback"><td class="memItemLeft" align="right" valign="top"><a id="ad86c2ca6fcb93cb79fade331ab9bd161"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><b>mSilenceLevel</b></td></tr>
<tr class="separator:ad86c2ca6fcb93cb79fade331ab9bd161 inherit pub_attribs_class_audio_io_callback"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc0174e4fb2174dee93b328b3642a3ad inherit pub_attribs_class_audio_io_callback"><td class="memItemLeft" align="right" valign="top"><a id="adc0174e4fb2174dee93b328b3642a3ad"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>mNumCaptureChannels</b></td></tr>
<tr class="separator:adc0174e4fb2174dee93b328b3642a3ad inherit pub_attribs_class_audio_io_callback"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5626d6ab71eb29c33bcfbf28675ff2bb inherit pub_attribs_class_audio_io_callback"><td class="memItemLeft" align="right" valign="top"><a id="a5626d6ab71eb29c33bcfbf28675ff2bb"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>mNumPlaybackChannels</b></td></tr>
<tr class="separator:a5626d6ab71eb29c33bcfbf28675ff2bb inherit pub_attribs_class_audio_io_callback"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff6a9c2de0361e0849d13af22058ed70 inherit pub_attribs_class_audio_io_callback"><td class="memItemLeft" align="right" valign="top"><a id="aff6a9c2de0361e0849d13af22058ed70"></a>
sampleFormat&#160;</td><td class="memItemRight" valign="bottom"><b>mCaptureFormat</b></td></tr>
<tr class="separator:aff6a9c2de0361e0849d13af22058ed70 inherit pub_attribs_class_audio_io_callback"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9c8d2b925893cce9490c2aac6f04776 inherit pub_attribs_class_audio_io_callback"><td class="memItemLeft" align="right" valign="top"><a id="af9c8d2b925893cce9490c2aac6f04776"></a>
unsigned long long&#160;</td><td class="memItemRight" valign="bottom"><b>mLostSamples</b> { 0 }</td></tr>
<tr class="separator:af9c8d2b925893cce9490c2aac6f04776 inherit pub_attribs_class_audio_io_callback"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbc78bd217ac181f0608437826288323 inherit pub_attribs_class_audio_io_callback"><td class="memItemLeft" align="right" valign="top"><a id="afbc78bd217ac181f0608437826288323"></a>
volatile bool&#160;</td><td class="memItemRight" valign="bottom"><b>mAudioThreadShouldCallFillBuffersOnce</b></td></tr>
<tr class="separator:afbc78bd217ac181f0608437826288323 inherit pub_attribs_class_audio_io_callback"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadfb73914835fe74d44827dd92ff87f3 inherit pub_attribs_class_audio_io_callback"><td class="memItemLeft" align="right" valign="top"><a id="aadfb73914835fe74d44827dd92ff87f3"></a>
volatile bool&#160;</td><td class="memItemRight" valign="bottom"><b>mAudioThreadFillBuffersLoopRunning</b></td></tr>
<tr class="separator:aadfb73914835fe74d44827dd92ff87f3 inherit pub_attribs_class_audio_io_callback"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89e2cd0f066e212e52d55a17d4cb7cb4 inherit pub_attribs_class_audio_io_callback"><td class="memItemLeft" align="right" valign="top"><a id="a89e2cd0f066e212e52d55a17d4cb7cb4"></a>
volatile bool&#160;</td><td class="memItemRight" valign="bottom"><b>mAudioThreadFillBuffersLoopActive</b></td></tr>
<tr class="separator:a89e2cd0f066e212e52d55a17d4cb7cb4 inherit pub_attribs_class_audio_io_callback"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60538f6dfa7acc0fdfce1d0bb7b77b4b inherit pub_attribs_class_audio_io_callback"><td class="memItemLeft" align="right" valign="top"><a id="a60538f6dfa7acc0fdfce1d0bb7b77b4b"></a>
wxLongLong&#160;</td><td class="memItemRight" valign="bottom"><b>mLastPlaybackTimeMillis</b></td></tr>
<tr class="separator:a60538f6dfa7acc0fdfce1d0bb7b77b4b inherit pub_attribs_class_audio_io_callback"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c07679eb2a0ffaea64f7a8a60e08860 inherit pub_attribs_class_audio_io_callback"><td class="memItemLeft" align="right" valign="top"><a id="a4c07679eb2a0ffaea64f7a8a60e08860"></a>
volatile double&#160;</td><td class="memItemRight" valign="bottom"><b>mLastRecordingOffset</b></td></tr>
<tr class="separator:a4c07679eb2a0ffaea64f7a8a60e08860 inherit pub_attribs_class_audio_io_callback"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a836366b03c64c705f9bae304ce0f21f9 inherit pub_attribs_class_audio_io_callback"><td class="memItemLeft" align="right" valign="top"><a id="a836366b03c64c705f9bae304ce0f21f9"></a>
PaError&#160;</td><td class="memItemRight" valign="bottom"><b>mLastPaError</b></td></tr>
<tr class="separator:a836366b03c64c705f9bae304ce0f21f9 inherit pub_attribs_class_audio_io_callback"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af87525a89e6bc418ad6ecba54fc62724 inherit pub_attribs_class_audio_io_callback"><td class="memItemLeft" align="right" valign="top"><a id="af87525a89e6bc418ad6ecba54fc62724"></a>
std::unique_ptr&lt; <a class="el" href="struct_audio_io_callback_1_1_scrub_state.html">ScrubState</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>mScrubState</b></td></tr>
<tr class="separator:af87525a89e6bc418ad6ecba54fc62724 inherit pub_attribs_class_audio_io_callback"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdc3bf223c67d160f3ae76e9ab091887 inherit pub_attribs_class_audio_io_callback"><td class="memItemLeft" align="right" valign="top"><a id="abdc3bf223c67d160f3ae76e9ab091887"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>mSilentScrub</b></td></tr>
<tr class="separator:abdc3bf223c67d160f3ae76e9ab091887 inherit pub_attribs_class_audio_io_callback"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8495e6681df17ff3e7cca3414384fd4 inherit pub_attribs_class_audio_io_callback"><td class="memItemLeft" align="right" valign="top"><a id="ab8495e6681df17ff3e7cca3414384fd4"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>mScrubSpeed</b></td></tr>
<tr class="separator:ab8495e6681df17ff3e7cca3414384fd4 inherit pub_attribs_class_audio_io_callback"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cc91bb354238c01c046a9a4c032cf20 inherit pub_attribs_class_audio_io_callback"><td class="memItemLeft" align="right" valign="top"><a id="a3cc91bb354238c01c046a9a4c032cf20"></a>
sampleCount&#160;</td><td class="memItemRight" valign="bottom"><b>mScrubDuration</b></td></tr>
<tr class="separator:a3cc91bb354238c01c046a9a4c032cf20 inherit pub_attribs_class_audio_io_callback"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a2fc775497444f377afbbd726f32d3b inherit pub_attribs_class_audio_io_callback"><td class="memItemLeft" align="right" valign="top"><a id="a7a2fc775497444f377afbbd726f32d3b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>mSimulateRecordingErrors</b> { false }</td></tr>
<tr class="separator:a7a2fc775497444f377afbbd726f32d3b inherit pub_attribs_class_audio_io_callback"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a5cd1d17c869adffd95a7201de970d3 inherit pub_attribs_class_audio_io_callback"><td class="memItemLeft" align="right" valign="top"><a id="a0a5cd1d17c869adffd95a7201de970d3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>mDetectUpstreamDropouts</b> { true }</td></tr>
<tr class="separator:a0a5cd1d17c869adffd95a7201de970d3 inherit pub_attribs_class_audio_io_callback"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_class_audio_io_callback"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_class_audio_io_callback')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="class_audio_io_callback.html">AudioIoCallback</a></td></tr>
<tr class="memitem:a5ad477da04332fd8d57d2301b4252da2 inherit pro_methods_class_audio_io_callback"><td class="memItemLeft" align="right" valign="top"><a id="a5ad477da04332fd8d57d2301b4252da2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetRecordingException</b> ()</td></tr>
<tr class="separator:a5ad477da04332fd8d57d2301b4252da2 inherit pro_methods_class_audio_io_callback"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a534b70c5edb138dd782a1fd27d6c611d inherit pro_methods_class_audio_io_callback"><td class="memItemLeft" align="right" valign="top"><a id="a534b70c5edb138dd782a1fd27d6c611d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ClearRecordingException</b> ()</td></tr>
<tr class="separator:a534b70c5edb138dd782a1fd27d6c611d inherit pro_methods_class_audio_io_callback"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_class_audio_io_callback"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_class_audio_io_callback')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="class_audio_io_callback.html">AudioIoCallback</a></td></tr>
<tr class="memitem:ad4bd61210c53a3c4589fcf9129eb4995 inherit pro_attribs_class_audio_io_callback"><td class="memItemLeft" align="right" valign="top"><a id="ad4bd61210c53a3c4589fcf9129eb4995"></a>
<a class="el" href="class_audacity_project.html">AudacityProject</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>mOwningProject</b></td></tr>
<tr class="separator:ad4bd61210c53a3c4589fcf9129eb4995 inherit pro_attribs_class_audio_io_callback"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3cf80ea5ba07344301d072fb22958bc inherit pro_attribs_class_audio_io_callback"><td class="memItemLeft" align="right" valign="top"><a id="ac3cf80ea5ba07344301d072fb22958bc"></a>
wxWeakRef&lt; <a class="el" href="class_meter_panel.html">MeterPanel</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>mInputMeter</b> {}</td></tr>
<tr class="separator:ac3cf80ea5ba07344301d072fb22958bc inherit pro_attribs_class_audio_io_callback"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae122264ce0b79a26a1eba759c4116f21 inherit pro_attribs_class_audio_io_callback"><td class="memItemLeft" align="right" valign="top"><a id="ae122264ce0b79a26a1eba759c4116f21"></a>
<a class="el" href="class_meter_panel.html">MeterPanel</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>mOutputMeter</b></td></tr>
<tr class="separator:ae122264ce0b79a26a1eba759c4116f21 inherit pro_attribs_class_audio_io_callback"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e75a4d1ea9ab083a471e18a8b452b5f inherit pro_attribs_class_audio_io_callback"><td class="memItemLeft" align="right" valign="top"><a id="a5e75a4d1ea9ab083a471e18a8b452b5f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>mUpdateMeters</b></td></tr>
<tr class="separator:a5e75a4d1ea9ab083a471e18a8b452b5f inherit pro_attribs_class_audio_io_callback"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a434bbe92af08ad84d860a265a9dc47f1 inherit pro_attribs_class_audio_io_callback"><td class="memItemLeft" align="right" valign="top"><a id="a434bbe92af08ad84d860a265a9dc47f1"></a>
volatile bool&#160;</td><td class="memItemRight" valign="bottom"><b>mUpdatingMeters</b></td></tr>
<tr class="separator:a434bbe92af08ad84d860a265a9dc47f1 inherit pro_attribs_class_audio_io_callback"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4df3d4347daf1800229316ad034cd3f2 inherit pro_attribs_class_audio_io_callback"><td class="memItemLeft" align="right" valign="top"><a id="a4df3d4347daf1800229316ad034cd3f2"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>mEmulateMixerOutputVol</b></td></tr>
<tr class="separator:a4df3d4347daf1800229316ad034cd3f2 inherit pro_attribs_class_audio_io_callback"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64e29c46367d946f710231cbcfb86fce inherit pro_attribs_class_audio_io_callback"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_audio_io_callback.html#a64e29c46367d946f710231cbcfb86fce">mInputMixerWorks</a></td></tr>
<tr class="memdesc:a64e29c46367d946f710231cbcfb86fce inherit pro_attribs_class_audio_io_callback"><td class="mdescLeft">&#160;</td><td class="mdescRight">Can we control the hardware input level?  <a href="class_audio_io_callback.html#a64e29c46367d946f710231cbcfb86fce">More...</a><br /></td></tr>
<tr class="separator:a64e29c46367d946f710231cbcfb86fce inherit pro_attribs_class_audio_io_callback"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8175c00f9048cd0b9172c41ee4ea2e41 inherit pro_attribs_class_audio_io_callback"><td class="memItemLeft" align="right" valign="top"><a id="a8175c00f9048cd0b9172c41ee4ea2e41"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><b>mMixerOutputVol</b></td></tr>
<tr class="separator:a8175c00f9048cd0b9172c41ee4ea2e41 inherit pro_attribs_class_audio_io_callback"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c0de9de40681aea143ec3ad893f28c6 inherit pro_attribs_class_audio_io_callback"><td class="memItemLeft" align="right" valign="top"><a id="a6c0de9de40681aea143ec3ad893f28c6"></a>
<a class="el" href="class_audio_i_o_listener.html">AudioIOListener</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>mListener</b></td></tr>
<tr class="separator:a6c0de9de40681aea143ec3ad893f28c6 inherit pro_attribs_class_audio_io_callback"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb560baa761cfa0ced61c8448d50fb53 inherit pro_attribs_class_audio_io_callback"><td class="memItemLeft" align="right" valign="top"><a id="aeb560baa761cfa0ced61c8448d50fb53"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>mUsingAlsa</b> { false }</td></tr>
<tr class="separator:aeb560baa761cfa0ced61c8448d50fb53 inherit pro_attribs_class_audio_io_callback"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17735ed8297744c0ddfc49d5ef867acf inherit pro_attribs_class_audio_io_callback"><td class="memItemLeft" align="right" valign="top"><a id="a17735ed8297744c0ddfc49d5ef867acf"></a>
wxMutex&#160;</td><td class="memItemRight" valign="bottom"><b>mSuspendAudioThread</b></td></tr>
<tr class="separator:a17735ed8297744c0ddfc49d5ef867acf inherit pro_attribs_class_audio_io_callback"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad56efd3ecf35065a07e6e9abe496ad93 inherit pro_attribs_class_audio_io_callback"><td class="memItemLeft" align="right" valign="top"><a id="ad56efd3ecf35065a07e6e9abe496ad93"></a>
wxAtomicInt&#160;</td><td class="memItemRight" valign="bottom"><b>mRecordingException</b> {}</td></tr>
<tr class="separator:ad56efd3ecf35065a07e6e9abe496ad93 inherit pro_attribs_class_audio_io_callback"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae59dedd1a88318d4a0b58446254459b1 inherit pro_attribs_class_audio_io_callback"><td class="memItemLeft" align="right" valign="top"><a id="ae59dedd1a88318d4a0b58446254459b1"></a>
std::vector&lt; std::pair&lt; double, double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>mLostCaptureIntervals</b></td></tr>
<tr class="separator:ae59dedd1a88318d4a0b58446254459b1 inherit pro_attribs_class_audio_io_callback"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c0b832ac8091f47f366cf75373fd42b inherit pro_attribs_class_audio_io_callback"><td class="memItemLeft" align="right" valign="top"><a id="a6c0b832ac8091f47f366cf75373fd42b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>mDetectDropouts</b> { true }</td></tr>
<tr class="separator:a6c0b832ac8091f47f366cf75373fd42b inherit pro_attribs_class_audio_io_callback"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a4ef6ef8e4b603033f82cbb95e773a2 inherit pro_attribs_class_audio_io_callback"><td class="memItemLeft" align="right" valign="top"><a id="a5a4ef6ef8e4b603033f82cbb95e773a2"></a>
struct <a class="el" href="struct_audio_io_callback_1_1_recording_schedule.html">AudioIoCallback::RecordingSchedule</a>&#160;</td><td class="memItemRight" valign="bottom"><b>mRecordingSchedule</b></td></tr>
<tr class="separator:a5a4ef6ef8e4b603033f82cbb95e773a2 inherit pro_attribs_class_audio_io_callback"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12b41bf63a93054f4443aa7a6a4845ae inherit pro_attribs_class_audio_io_callback"><td class="memItemLeft" align="right" valign="top"><a id="a12b41bf63a93054f4443aa7a6a4845ae"></a>
struct <a class="el" href="struct_audio_io_callback_1_1_playback_schedule.html">AudioIoCallback::PlaybackSchedule</a>&#160;</td><td class="memItemRight" valign="bottom"><b>mPlaybackSchedule</b></td></tr>
<tr class="separator:a12b41bf63a93054f4443aa7a6a4845ae inherit pro_attribs_class_audio_io_callback"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74ac4fc388f60ec1ce40863a3edf3043 inherit pro_attribs_class_audio_io_callback"><td class="memItemLeft" align="right" valign="top"><a id="a74ac4fc388f60ec1ce40863a3edf3043"></a>
struct <a class="el" href="struct_audio_io_callback_1_1_time_queue.html">AudioIoCallback::TimeQueue</a>&#160;</td><td class="memItemRight" valign="bottom"><b>mTimeQueue</b></td></tr>
<tr class="separator:a74ac4fc388f60ec1ce40863a3edf3043 inherit pro_attribs_class_audio_io_callback"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_static_attribs_class_audio_io_callback"><td colspan="2" onclick="javascript:toggleInherit('pro_static_attribs_class_audio_io_callback')"><img src="closed.png" alt="-"/>&#160;Static Protected Attributes inherited from <a class="el" href="class_audio_io_callback.html">AudioIoCallback</a></td></tr>
<tr class="memitem:ace2ebe1d39f1630bd348756f086b3a89 inherit pro_static_attribs_class_audio_io_callback"><td class="memItemLeft" align="right" valign="top"><a id="ace2ebe1d39f1630bd348756f086b3a89"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>mCachedPlaybackIndex</b> = -1</td></tr>
<tr class="separator:ace2ebe1d39f1630bd348756f086b3a89 inherit pro_static_attribs_class_audio_io_callback"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44da7151c8460b05c93dbc811eae977b inherit pro_static_attribs_class_audio_io_callback"><td class="memItemLeft" align="right" valign="top"><a id="a44da7151c8460b05c93dbc811eae977b"></a>
static std::vector&lt; long &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>mCachedPlaybackRates</b></td></tr>
<tr class="separator:a44da7151c8460b05c93dbc811eae977b inherit pro_static_attribs_class_audio_io_callback"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab06377b748a34fcfd688efb565e1cb33 inherit pro_static_attribs_class_audio_io_callback"><td class="memItemLeft" align="right" valign="top"><a id="ab06377b748a34fcfd688efb565e1cb33"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>mCachedCaptureIndex</b> = -1</td></tr>
<tr class="separator:ab06377b748a34fcfd688efb565e1cb33 inherit pro_static_attribs_class_audio_io_callback"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bf484f2f589ac90b8d96215f565b455 inherit pro_static_attribs_class_audio_io_callback"><td class="memItemLeft" align="right" valign="top"><a id="a7bf484f2f589ac90b8d96215f565b455"></a>
static std::vector&lt; long &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>mCachedCaptureRates</b></td></tr>
<tr class="separator:a7bf484f2f589ac90b8d96215f565b455 inherit pro_static_attribs_class_audio_io_callback"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a809e195577a0f816c6d7334a695496f2 inherit pro_static_attribs_class_audio_io_callback"><td class="memItemLeft" align="right" valign="top"><a id="a809e195577a0f816c6d7334a695496f2"></a>
static std::vector&lt; long &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>mCachedSampleRates</b></td></tr>
<tr class="separator:a809e195577a0f816c6d7334a695496f2 inherit pro_static_attribs_class_audio_io_callback"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58038c1ecf56848ea7fcb366d1d8d92c inherit pro_static_attribs_class_audio_io_callback"><td class="memItemLeft" align="right" valign="top"><a id="a58038c1ecf56848ea7fcb366d1d8d92c"></a>
static double&#160;</td><td class="memItemRight" valign="bottom"><b>mCachedBestRateIn</b> = 0.0</td></tr>
<tr class="separator:a58038c1ecf56848ea7fcb366d1d8d92c inherit pro_static_attribs_class_audio_io_callback"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a378cdf4319c4ff6fe59742b9428adbb7 inherit pro_static_attribs_class_audio_io_callback"><td class="memItemLeft" align="right" valign="top"><a id="a378cdf4319c4ff6fe59742b9428adbb7"></a>
static double&#160;</td><td class="memItemRight" valign="bottom"><b>mCachedBestRateOut</b></td></tr>
<tr class="separator:a378cdf4319c4ff6fe59742b9428adbb7 inherit pro_static_attribs_class_audio_io_callback"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="class_audio_i_o.html" title="AudioIO uses the PortAudio library to play and record sound.">AudioIO</a> uses the PortAudio library to play and record sound. </p>
<p>Great care and attention to detail are necessary for understanding and modifying this system. The code in this file is run from three different thread contexts: the UI thread, the disk thread (which this file creates and maintains; in the code, this is called the Audio Thread), and the PortAudio callback thread. To highlight this deliniation, the file is divided into three parts based on what thread context each function is intended to run in.</p>
<dl class="section user"><dt>EXPERIMENTAL_MIDI_OUT</dt><dd>If EXPERIMENTAL_MIDI_OUT is defined, this class also manages MIDI playback. The reason for putting MIDI here rather than in, say, class MidiIO, is that there is no high-level synchronization and transport architecture, so Audio and MIDI must be coupled in order to start/stop/pause and synchronize them.</dd></dl>
<dl class="section user"><dt>MIDI With Audio</dt><dd>When Audio and MIDI play simultaneously, MIDI synchronizes to Audio. This is necessary because the Audio sample clock is not the same hardware as the system time used to schedule MIDI messages. MIDI is synchronized to Audio because it is simple to pause or rush the dispatch of MIDI messages, but generally impossible to pause or rush synchronous audio samples (without distortion).</dd></dl>
<dl class="section user"><dt></dt><dd>MIDI output is driven by yet another thread. In principle, we could output timestamped MIDI data at the same time we fill audio buffers from disk, but audio buffers are filled far in advance of playback time, and there is a lower latency thread (PortAudio's callback) that actually sends samples to the output device. The relatively low latency to the output device allows Audacity to stop audio output quickly. We want the same behavior for MIDI, but there is not periodic callback from PortMidi (because MIDI is asynchronous), so this function is performed by the MidiThread class.</dd></dl>
<dl class="section user"><dt></dt><dd>When Audio is running, MIDI is synchronized to Audio. Globals are set in the Audio callback (audacityAudioCallback) for use by a time function that reports milliseconds to PortMidi. (Details below.)</dd></dl>
<dl class="section user"><dt>MIDI Without Audio</dt><dd>When Audio is not running, PortMidi uses its own millisecond timer since there is no audio to synchronize to. (Details below.)</dd></dl>
<dl class="section user"><dt>Implementation Notes and Details for MIDI</dt><dd>When opening devices, successAudio and successMidi indicate errors if false, so normally both are true. Use playbackChannels, captureChannels and mMidiPlaybackTracks.IsEmpty() to determine if Audio or MIDI is actually in use.</dd></dl>
<dl class="section user"><dt>Audio Time</dt><dd>Normally, the current time during playback is given by the variable mTime. mTime normally advances by frames / samplerate each time an audio buffer is output by the audio callback. However, Audacity has a speed control that can perform continuously variable time stretching on audio. This is achieved in two places: the playback "mixer" that generates the samples for output processes the audio according to the speed control. In a separate algorithm, the audio callback updates mTime by (frames / samplerate) * factor, where factor reflects the speed at mTime. This effectively integrates speed to get position. Negative speeds are allowed too, for instance in scrubbing.</dd></dl>
<dl class="section user"><dt>The Big Picture</dt><dd><pre class="fragment">Sample
Time (in seconds, = total_sample_count / sample_rate)
  ^
  |                                             /         /
  |             y=x-mSystemTimeMinusAudioTime /         /
  |                                         /     #   /
  |                                       /         /
  |                                     /   # &lt;- callbacks (#) showing
  |                                   /#        /   lots of timing jitter.
  |       top line is "full buffer" /         /     Some are later,
  |                     condition /         /       indicating buffer is
  |                             /         /         getting low. Plot
  |                           /     #   /           shows sample time
  |                         /    #    /             (based on how many
  |                       /    #    /               samples previously
  |                     /         /                 *written*) vs. real
  |                   / #       /                   time.
  |                 /&lt;-------&gt;/ audio latency
  |               /#       v/
  |             /         / bottom line is "empty buffer"
  |           /   #     /      condition = DAC output time =
  |         /         /
  |       /      # &lt;-- rapid callbacks as buffer is filled
  |     /         /
0 +...+---------#----------------------------------------------------&gt;
  0 ^ |         |                                            real time
    | |         first callback time
    | mSystemMinusAudioTime
    |
    Probably the actual real times shown in this graph are very large
    in practice (&gt; 350,000 sec.), so the X "origin" might be when
    the computer was booted or 1970 or something.</pre></dd></dl>
<p>To estimate the true DAC time (needed to synchronize MIDI), we need a mapping from track time to DAC time. The estimate is the theoretical time of the full buffer (top diagonal line) + audio latency. To estimate the top diagonal line, we "draw" the line to be at least as high as any sample time corresponding to a callback (#), and we slowly lower the line in case the sample clock is slow or the system clock is fast, preventing the estimated line from drifting too far from the actual callback observations. The line is occasionally "bumped" up by new callback observations, but continuously "lowered" at a very low rate. All adjustment is accomplished by changing mSystemMinusAudioTime, shown here as the X-intercept.<br />
 theoreticalFullBufferTime = realTime - mSystemMinusAudioTime<br />
 To estimate audio latency, notice that the first callback happens on an empty buffer, but the buffer soon fills up. This will cause a rapid re-estimation of mSystemMinusAudioTime. (The first estimate of mSystemMinusAudioTime will simply be the real time of the first callback time.) By watching these changes, which happen within ms of starting, we can estimate the buffer size and thus audio latency. So, to map from track time to real time, we compute:<br />
 DACoutputTime = trackTime + mSystemMinusAudioTime<br />
 There are some additional details to avoid counting samples while paused or while waiting for initialization, MIDI latency, etc. Also, in the code, track time is measured with respect to the track origin, so there's an extra term to add (mT0) if you start somewhere in the middle of the track. Finally, when a callback occurs, you might expect there is room in the output buffer for the requested frames, so maybe the "full buffer" sample time should be based not on the first sample of the callback, but the last sample time + 1 sample. I suspect, at least on Linux, that the callback occurs as soon as the last callback completes, so the buffer is really full, and the callback thread is going to block waiting for space in the output buffer.</p>
<dl class="section user"><dt>Midi Time</dt><dd>MIDI is not warped according to the speed control. This might be something that should be changed. (Editorial note: Wouldn't it make more sense to display audio at the correct time and allow users to stretch audio the way they can stretch MIDI?) For now, MIDI plays at 1 second per second, so it requires an unwarped clock. In fact, MIDI time synchronization requires a millisecond clock that does not pause. Note that mTime will stop progress when the Pause button is pressed, even though audio samples (zeros) continue to be output.</dd></dl>
<dl class="section user"><dt></dt><dd>Therefore, we define the following interface for MIDI timing: <ul>
<li><code>AudioTime()</code> is the time based on all samples written so far, including zeros output during pauses. AudioTime() is based on the start location mT0, not zero. </li>
<li><code>PauseTime()</code> is the amount of time spent paused, based on a count of zero-padding samples output. </li>
<li><code>MidiTime()</code> is an estimate in milliseconds of the current audio output time + 1s. In other words, what audacity track time corresponds to the audio (plus pause insertions) at the DAC output?</li>
</ul>
</dd></dl>
<dl class="section user"><dt>AudioTime() and PauseTime() computation</dt><dd>AudioTime() is simply mT0 + mNumFrames / mRate. mNumFrames is incremented in each audio callback. Similarly, PauseTime() is mNumPauseFrames / mRate. mNumPauseFrames is also incremented in each audio callback when a pause is in effect or audio output is ready to start.</dd></dl>
<dl class="section user"><dt>MidiTime() computation</dt><dd>MidiTime() is computed based on information from PortAudio's callback, which estimates the system time at which the current audio buffer will be output. Consider the (unimplemented) function RealToTrack() that maps real audio write time to track time. If writeTime is the system time for the first sample of the current output buffer, and if we are in the callback, so AudioTime() also refers to the first sample of the buffer, then <br />
 RealToTrack(writeTime) = AudioTime() - PauseTime()<br />
 We want to know RealToTrack of the current time (when we are not in the callback, so we use this approximation for small d: <br />
 RealToTrack(t + d) = RealToTrack(t) + d, or <br />
 Letting t = writeTime and d = (systemTime - writeTime), we can substitute to get:<br />
 RealToTrack(systemTime) = RealToTrack(writeTime) + systemTime - writeTime<br />
 = AudioTime() - PauseTime() + (systemTime - writeTime) <br />
 MidiTime() should include pause time, so that it increases smoothly, and audioLatency so that MidiTime() corresponds to the time of audio output rather than audio write times. Also MidiTime() is offset by 1 second to avoid negative time at startup, so add 1: <br />
 MidiTime(systemTime) in seconds<br />
 = RealToTrack(systemTime) + PauseTime() - audioLatency + 1 <br />
 = AudioTime() + (systemTime - writeTime) - audioLatency + 1 <br />
 (Note that audioLatency is called mAudioOutLatency in the code.) When we schedule a MIDI event with track time TT, we need to map TT to a PortMidi timestamp. The PortMidi timestamp is exactly MidiTime(systemTime) in ms units, and <br />
 MidiTime(x) = RealToTrack(x) + PauseTime() + 1, so <br />
 timestamp = TT + PauseTime() + 1 - midiLatency <br />
 Note 1: The timestamp is incremented by the PortMidi stream latency (midiLatency) so we subtract midiLatency here for the timestamp passed to PortMidi. <br />
 Note 2: Here, we're setting x to the time at which RealToTrack(x) = TT, so then MidiTime(x) is the desired timestamp. To be completely correct, we should assume that MidiTime(x + d) = MidiTime(x) + d, and consider that we compute MidiTime(systemTime) based on the current* system time, but we really want the MidiTime(x) for some future time corresponding when MidiTime(x) = TT.)</dd></dl>
<dl class="section user"><dt></dt><dd>Also, we should assume PortMidi was opened with mMidiLatency, and that MIDI messages become sound with a delay of mSynthLatency. Therefore, the final timestamp calculation is: <br />
 timestamp = TT + PauseTime() + 1 - (mMidiLatency + mSynthLatency) <br />
 (All units here are seconds; some conversion is needed in the code.)</dd></dl>
<dl class="section user"><dt></dt><dd>The difference AudioTime() - PauseTime() is the time "cursor" for MIDI. When the speed control is used, MIDI and Audio will become unsynchronized. In particular, MIDI will not be synchronized with the visual cursor, which moves with scaled time reported in mTime.</dd></dl>
<dl class="section user"><dt>Timing in Linux</dt><dd>It seems we cannot get much info from Linux. We can read the time when we get a callback, and we get a variable frame count (it changes from one callback to the next). Returning to the RealToTrack() equations above: <br />
 RealToTrack(outputTime) = AudioTime() - PauseTime() - bufferDuration <br />
 where outputTime should be PortAudio's estimate for the most recent output buffer, but at least on my Dell Latitude E7450, PortAudio is getting zero from ALSA, so we need to find a proxy for this.</dd></dl>
<dl class="section user"><dt>Estimating outputTime (Plan A, assuming double-buffered, fixed-size buffers, please skip to Plan B)</dt><dd>One can expect the audio callback to happen as soon as there is room in the output for another block of samples, so we could just measure system time at the top of the callback. Then we could add the maximum delay buffered in the system. E.g. if there is simple double buffering and the callback is computing one of the buffers, the callback happens just as one of the buffers empties, meaning the other buffer is full, so we have exactly one buffer delay before the next computed sample is output.</dd></dl>
<p>If computation falls behind a bit, the callback will be later, so the delay to play the next computed sample will be less. I think a reasonable way to estimate the actual output time is to assume that the computer is mostly keeping up and that <em>most</em> callbacks will occur immediately when there is space. Note that the most likely reason for the high-priority audio thread to fall behind is the callback itself, but the start of the callback should be pretty consistently keeping up.</p>
<p>Also, we do not have to have a perfect estimate of the time. Suppose we estimate a linear mapping from sample count to system time by saying that the sample count maps to the system time at the most recent callback, and set the slope to 1% slower than real time (as if the sample clock is slow). Now, at each callback, if the callback seems to occur earlier than expected, we can adjust the mapping to be earlier. The earlier the callback, the more accurate it must be. On the other hand, if the callback is later than predicted, it must be a delayed callback (or else the sample clock is more than 1% slow, which is really a hardware problem.) How bad can this be? Assuming callbacks every 30ms (this seems to be what I'm observing in a default setup), you'll be a maximum of 1ms off even if 2 out of 3 callbacks are late. This is pretty reasonable given that PortMIDI clock precision is 1ms. If buffers are larger and callback timing is more erratic, errors will be larger, but even a few ms error is probably OK.</p>
<dl class="section user"><dt>Estimating outputTime (Plan B, variable framesPerBuffer in callback, please skip to Plan C)</dt><dd>ALSA is complicated because we get varying values of framesPerBuffer from callback to callback. Assume you get more frames when the callback is later (because there is more accumulated input to deliver and more more accumulated room in the output buffers). So take the current time and subtract the duration of the frame count in the current callback. This should be a time position that is relatively jitter free (because we estimated the lateness by frame count and subtracted that out). This time position intuitively represents the current ADC time, or if no input, the time of the tail of the output buffer. If we wanted DAC time, we'd have to add the total output buffer duration, which should be reported by PortAudio. (If PortAudio is wrong, we'll be systematically shifted in time by the error.)</dd></dl>
<p>Since there is still bound to be jitter, we can smooth these estimates. First, we will assume a linear mapping from system time to audio time with slope = 1, so really it's just the offset we need, which is going to be a double that we can read/write atomically without locks or anything fancy. (<a class="el" href="class_maybe.html" title="Like a smart pointer, allows for object to not exist (nullptr)">Maybe</a> it should be "volatile".)</p>
<p>To improve the estimate, we get a new offset every callback, so we can create a "smooth" offset by using a simple regression model (also this could be seen as a first order filter). The following formula updates smooth_offset with a new offset estimate in the callback: smooth_offset = smooth_offset * 0.9 + new_offset_estimate * 0.1 Since this is smooth, we'll have to be careful to give it a good initial value to avoid a long convergence.</p>
<dl class="section user"><dt>Estimating outputTime (Plan C)</dt><dd>ALSA is complicated because we get varying values of framesPerBuffer from callback to callback. It seems there is a lot of variation in callback times and buffer space. One solution would be to go to fixed size double buffer, but Audacity seems to work better as is, so Plan C is to rely on one invariant which is that the output buffer cannot overflow, so there's a limit to how far ahead of the DAC time we can be writing samples into the buffer. Therefore, we'll assume that the audio clock runs slow by about 0.2% and we'll assume we're computing at that rate. If the actual output position is ever ahead of the computed position, we'll increase the computed position to the actual position. Thus whenever the buffer is less than near full, we'll stay ahead of DAC time, falling back at a rate of about 0.2% until eventually there's another near-full buffer callback that will push the time back ahead.</dd></dl>
<dl class="section user"><dt>Interaction between MIDI, Audio, and Pause</dt><dd>When Pause is used, PauseTime() will increase at the same rate as AudioTime(), and no more events will be output. Because of the time advance of mAudioOutputLatency + MIDI_SLEEP + latency and the fact that AudioTime() advances stepwise by mAudioBufferDuration, some extra MIDI might be output, but the same is true of audio: something like mAudioOutputLatency audio samples will be in the output buffer (with up to mAudioBufferDuration additional samples, depending on when the Pause takes effect). When playback is resumed, there will be a slight delay corresponding to the extra data previously sent. Again, the same is true of audio. Audio and MIDI will not pause and resume at exactly the same times, but their pause and resume times will be within the low tens of milliseconds, and the streams will be synchronized in any case. I.e. if audio pauses 10ms earlier than MIDI, it will resume 10ms earlier as well.</dd></dl>
<dl class="section user"><dt>PortMidi Latency Parameter</dt><dd>PortMidi has a "latency" parameter that is added to all timestamps. This value must be greater than zero to enable timestamp-based timing, but serves no other function, so we will set it to 1. All timestamps must then be adjusted down by 1 before messages are sent. This adjustment is on top of all the calculations described above. It just seem too complicated to describe everything in complete detail in one place.</dd></dl>
<dl class="section user"><dt>Midi with a time track</dt><dd>When a variable-speed time track is present, MIDI events are output with the times used by the time track (rather than the raw times). This ensures MIDI is synchronized with audio.</dd></dl>
<dl class="section user"><dt>Midi While Recording Only or Without Audio Playback</dt><dd>To reduce duplicate code and to ensure recording is synchronised with MIDI, a portaudio stream will always be used, even when there is no actual audio output. For recording, this ensures that the recorded audio will by synchronized with the MIDI (otherwise, it gets out-of- sync if played back with correct timing).</dd></dl>
<dl class="section user"><dt>NoteTrack PlayLooped</dt><dd>When mPlayLooped is true, output is supposed to loop from mT0 to mT1. For NoteTracks, we interpret this to mean that any note-on or control change in the range mT0 &lt;= t &lt; mT1 is sent (notes that start before mT0 are not played even if they extend beyond mT0). Then, all notes are turned off. Events in the range mT0 &lt;= t &lt; mT1 are then repeated, offset by (mT1 - mT0), etc. We do NOT go back to the beginning and play all control changes (update events) up to mT0, nor do we "undo" any state changes between mT0 and mT1.</dd></dl>
<dl class="section user"><dt>NoteTrack PlayLooped Implementation</dt><dd>The mIterator object (an Alg_iterator) returns NULL when there are no more events scheduled before mT1. At mT1, we want to output all notes off messages, but the FillMidiBuffers() loop will exit if mNextEvent is NULL, so we create a "fake" mNextEvent for this special "event" of sending all notes off. After that, we destroy the iterator and use PrepareMidiIterator() to set up a NEW one. At each iteration, time must advance by (mT1 - mT0), so the accumulated complete loop time (in "unwarped," track time) is computed by MidiLoopOffset().</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000001">Todo:</a></b></dt><dd>run through all functions called from audio and portaudio threads to verify they are thread-safe. Note that synchronization of the style: "A sets flag to signal B, B clears flag to acknowledge completion" is not thread safe in a general multiple-CPU context. For example, B can write to a buffer and set a completion flag. The flag write can occur before the buffer write due to out-of-order execution. Then A can see the flag and read the buffer before buffer writes complete.</dd></dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a6489917b96acd5c4868b42724f1245a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6489917b96acd5c4868b42724f1245a3">&#9670;&nbsp;</a></span>GetBestRate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double AudioIO::GetBestRate </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>capturing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>playing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sampleRate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a valid sample rate that is supported by the current I/O device(s). </p>
<p>The return from this function is used to determine the sample rate that audacity actually runs the audio I/O stream at. if there is no suitable rate available from the hardware, it returns 0. The sampleRate argument gives the desired sample rate (the rate of the audio to be handeled, i.e. the currently Project Rate). capturing is true if the stream is capturing one or more audio channels, and playing is true if one or more channels are being played. </p>

</div>
</div>
<a id="a134b6a56921f9c6bd197d80de4ddce48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a134b6a56921f9c6bd197d80de4ddce48">&#9670;&nbsp;</a></span>GetDeviceInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">wxString AudioIO::GetDeviceInfo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get diagnostic information on all the available audio I/O devices. </p>

</div>
</div>
<a id="a871ad77e029d77ff4ae461b2be5325cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a871ad77e029d77ff4ae461b2be5325cd">&#9670;&nbsp;</a></span>GetInputSourceNames()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">wxArrayString AudioIO::GetInputSourceNames </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the list of inputs to the current mixer device. </p>
<p>Returns an array of strings giving the names of the inputs to the soundcard mixer (driven by PortMixer) </p>

</div>
</div>
<a id="a71facd3c7274394b70eaff652e1bc97e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71facd3c7274394b70eaff652e1bc97e">&#9670;&nbsp;</a></span>GetOptimalSupportedSampleRate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int AudioIO::GetOptimalSupportedSampleRate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a supported sample rate which can be used a an optimal default. </p>
<p>Currently, this uses the first supported rate in the list [44100, 48000, highest sample rate]. Used in Project as a default value for project rates if one cannot be retrieved from the preferences. So all in all not that useful or important really</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000002">Todo:</a></b></dt><dd>: should this take into account PortAudio's value for PaDeviceInfo::defaultSampleRate? In principal this should let us work out which rates are "real" and which resampled in the drivers, and so prefer the real rates. </dd></dl>

</div>
</div>
<a id="adaf7977e341e8012b03dca8c733f24e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaf7977e341e8012b03dca8c733f24e1">&#9670;&nbsp;</a></span>GetStreamTime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double AudioIO::GetStreamTime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>During playback, the track time most recently played. </p>
<p>When playing looped, this will start from t0 again, too. So the returned time should be always between t0 and t1 </p>

</div>
</div>
<a id="a66836a8e3a6687b0c6c0220685e51144"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66836a8e3a6687b0c6c0220685e51144">&#9670;&nbsp;</a></span>GetSupportedCaptureRates()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; long &gt; AudioIO::GetSupportedCaptureRates </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>devIndex</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rate</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a list of sample rates the input (recording) device supports. </p>
<p>If no information about available sample rates can be fetched, an empty list is returned.</p>
<p>You can explicitely give the index of the device. If you don't give it, the currently selected device from the preferences will be used.</p>
<p>You may also specify a rate for which to check in addition to the standard rates. </p>

</div>
</div>
<a id="a9abda9144bad168794547234df2a1c4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9abda9144bad168794547234df2a1c4e">&#9670;&nbsp;</a></span>GetSupportedPlaybackRates()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; long &gt; AudioIO::GetSupportedPlaybackRates </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>DevIndex</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rate</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a list of sample rates the output (playback) device supports. </p>
<p>If no information about available sample rates can be fetched, an empty list is returned.</p>
<p>You can explicitely give the index of the device. If you don't give it, the currently selected device from the preferences will be used.</p>
<p>You may also specify a rate for which to check in addition to the standard rates. </p>

</div>
</div>
<a id="a59a87873003096edc7c4359ed5de5ecb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59a87873003096edc7c4359ed5de5ecb">&#9670;&nbsp;</a></span>GetSupportedSampleRates()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; long &gt; AudioIO::GetSupportedSampleRates </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>playDevice</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>recDevice</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rate</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a list of sample rates the current input/output device combination supports. </p>
<p>Since there is no concept (yet) for different input/output sample rates, this currently returns only sample rates that are supported on both the output and input device. If no information about available sample rates can be fetched, it returns a default list. You can explicitely give the indexes of the playDevice/recDevice. If you don't give them, the selected devices from the preferences will be used. You may also specify a rate for which to check in addition to the standard rates. </p>

</div>
</div>
<a id="aef42a8e615a55e2b914a989e8b63af0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef42a8e615a55e2b914a989e8b63af0b">&#9670;&nbsp;</a></span>HandleDeviceChange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AudioIO::HandleDeviceChange </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>update state after changing what audio devices are selected </p>
<p>Called when the devices stored in the preferences are changed to update the audio mixer capabilities</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000003">Todo:</a></b></dt><dd>: Make this do a sample rate query and store the result in the <a class="el" href="class_audio_i_o.html" title="AudioIO uses the PortAudio library to play and record sound.">AudioIO</a> object to avoid doing it later? Would simplify the GetSupported*Rate functions considerably </dd></dl>

</div>
</div>
<a id="a104cc037e35b66adb8864a35e8376f8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a104cc037e35b66adb8864a35e8376f8e">&#9670;&nbsp;</a></span>InputMixerWorks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AudioIO::InputMixerWorks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find out if the input hardware level control is available. </p>
<p>Checks the mInputMixerWorks variable, which is set up in <a class="el" href="class_audio_i_o.html#aef42a8e615a55e2b914a989e8b63af0b" title="update state after changing what audio devices are selected">AudioIO::HandleDeviceChange()</a>. External people care, because we want to disable the UI if it doesn't work. </p>

</div>
</div>
<a id="a654d0ad7189af7767a658cbb98505fd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a654d0ad7189af7767a658cbb98505fd5">&#9670;&nbsp;</a></span>IsAudioTokenActive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AudioIO::IsAudioTokenActive </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>token</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the stream is active, or even if audio I/O is busy cleaning up its data or writing to disk. </p>
<p>This is used by <a class="el" href="class_track_panel.html" title="The TrackPanel class coordinates updates and operations on the main part of the screen which contains...">TrackPanel</a> to determine when a track has been completely recorded, and it's safe to flush to disk. </p>

</div>
</div>
<a id="a8241ebe3d067da25f0b987d599c18e0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8241ebe3d067da25f0b987d599c18e0a">&#9670;&nbsp;</a></span>IsAvailable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AudioIO::IsAvailable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_audacity_project.html">AudacityProject</a> *&#160;</td>
          <td class="paramname"><em>projecT</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to automatically set an acceptable volume. </p>

</div>
</div>
<a id="a141109b199851f00d55507de40737eb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a141109b199851f00d55507de40737eb1">&#9670;&nbsp;</a></span>IsBusy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AudioIO::IsBusy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if audio i/o is busy starting, stopping, playing, or recording. </p>
<p>When this is false, it's safe to start playing or recording </p>

</div>
</div>
<a id="ae69fc36ead257005079701907f7be714"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae69fc36ead257005079701907f7be714">&#9670;&nbsp;</a></span>IsStreamActive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AudioIO::IsStreamActive </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the audio i/o is running at all, but not during cleanup. </p>
<p>Doesn't return true if the device has been closed but some disk i/o or cleanup is still going on. If you want to know if it's safe to start a NEW stream, use <a class="el" href="class_audio_i_o.html#a141109b199851f00d55507de40737eb1" title="Returns true if audio i/o is busy starting, stopping, playing, or recording.">IsBusy()</a> </p>

</div>
</div>
<a id="abc4c1f9f7609603270df993ee8af1af2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc4c1f9f7609603270df993ee8af1af2">&#9670;&nbsp;</a></span>OutputMixerEmulated()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AudioIO::OutputMixerEmulated </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find out if the output level control is being emulated via software attenuation. </p>
<p>Checks the mEmulateMixerOutputVol variable, which is set up in <a class="el" href="class_audio_i_o.html#aef42a8e615a55e2b914a989e8b63af0b" title="update state after changing what audio devices are selected">AudioIO::HandleDeviceChange()</a>. External classes care, because we want to modify the UI if it doesn't work. </p>

</div>
</div>
<a id="a447c4b556a0f66a61ead1c97ed4ae7e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a447c4b556a0f66a61ead1c97ed4ae7e7">&#9670;&nbsp;</a></span>StartMonitoring()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AudioIO::StartMonitoring </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sampleRate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start up Portaudio for capture and recording as needed for input monitoring and software playthrough only. </p>
<p>This uses the Default project sample format, current sample rate, and selected number of input channels to open the recording device and start reading input data. If software playthrough is enabled, it also opens the output device in stereo to play the data through </p>

</div>
</div>
<a id="a9b17ce46ff4cc72fed5d125008903422"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b17ce46ff4cc72fed5d125008903422">&#9670;&nbsp;</a></span>StartStream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AudioIO::StartStream </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_transport_tracks.html">TransportTracks</a> &amp;&#160;</td>
          <td class="paramname"><em>tracks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>t0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_audio_i_o_start_stream_options.html">AudioIOStartStreamOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start recording or playing back audio. </p>
<p>Allocates buffers for recording and playback, gets the Audio thread to fill them, and sets the stream rolling. If successful, returns a token identifying this particular stream instance. For use with <a class="el" href="class_audio_i_o.html#ae69fc36ead257005079701907f7be714" title="Returns true if the audio i/o is running at all, but not during cleanup.">IsStreamActive()</a> below </p>

</div>
</div>
<a id="a018ef510a8616f1feeb0f542f82b1d44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a018ef510a8616f1feeb0f542f82b1d44">&#9670;&nbsp;</a></span>StopStream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AudioIO::StopStream </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stop recording, playback or input monitoring. </p>
<p>Does quite a bit of housekeeping, including switching off monitoring, flushing recording buffers out to wave tracks, and applies latency correction to recorded tracks if necessary </p>

</div>
</div>
<a id="acfaf9b48ca72d2d34ebfb8873e0ae7dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfaf9b48ca72d2d34ebfb8873e0ae7dd">&#9670;&nbsp;</a></span>ValidateDeviceNames()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool AudioIO::ValidateDeviceNames </td>
          <td>(</td>
          <td class="paramtype">const wxString &amp;&#160;</td>
          <td class="paramname"><em>play</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wxString &amp;&#160;</td>
          <td class="paramname"><em>rec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ensure selected device names are valid. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a4d794f0244d6be2f833a6627cbfcdae8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d794f0244d6be2f833a6627cbfcdae8">&#9670;&nbsp;</a></span>NumStandardRates</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int AudioIO::NumStandardRates</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= <span class="keyword">sizeof</span>(<a class="code" href="class_audio_i_o.html#a42f4cf4090548388aa1c762bb59778ba">AudioIO::StandardRates</a>) /</div><div class="line">                                      <span class="keyword">sizeof</span>(<a class="code" href="class_audio_i_o.html#a42f4cf4090548388aa1c762bb59778ba">AudioIO::StandardRates</a>[0])</div></div><!-- fragment -->
<p>How many standard sample rates there are. </p>

</div>
</div>
<a id="a42f4cf4090548388aa1c762bb59778ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42f4cf4090548388aa1c762bb59778ba">&#9670;&nbsp;</a></span>StandardRates</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int AudioIO::StandardRates</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div><div class="line">   8000,</div><div class="line">   11025,</div><div class="line">   16000,</div><div class="line">   22050,</div><div class="line">   32000,</div><div class="line">   44100,</div><div class="line">   48000,</div><div class="line">   88200,</div><div class="line">   96000,</div><div class="line">   176400,</div><div class="line">   192000,</div><div class="line">   352800,</div><div class="line">   384000</div><div class="line">}</div></div><!-- fragment -->
<p>Array of common audio sample rates. </p>
<p>These are the rates we will always support, regardless of hardware support for them (by resampling in audacity if needed) </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="_audio_i_o_8h_source.html">AudioIO.h</a></li>
<li>src/AudioIO.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_audio_i_o.html">AudioIO</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.15 </li>
  </ul>
</div>
</body>
</html>
